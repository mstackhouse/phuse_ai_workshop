#' Generate metadata for data objects in an environment
#'
#' Extracts metadata information from all data frames present in a given environment,
#' including dimensions, column names, types, and labels.
#'
#' @param data_env An environment containing data objects to analyze
#'
#' @return A named list where each element corresponds to a data frame in the environment.
#'   Each element contains:
#'   \describe{
#'     \item{type}{The object type (e.g., "data.frame")}
#'     \item{nrows}{Number of rows in the data frame}
#'     \item{ncols}{Number of columns in the data frame}
#'     \item{columns}{A list containing column names, types, and labels}
#'     \item{summary}{A formatted summary string of columns and data types}
#'   }
generate_data_metadata <- function(data_env) {
  metadata_list <- list()

  for (obj_name in ls(envir = data_env)) {
    obj <- get(obj_name, envir = data_env)

    if (is.data.frame(obj)) {
      metadata_list[[obj_name]] <- list(
        type = "data.frame",
        nrows = nrow(obj),
        ncols = ncol(obj),
        columns = paste(
          sapply(names(obj), function(col_name) {
            sprintf("%s : %s : %s",
              col_name,
              class(obj[[col_name]])[1],
              attr(obj[[col_name]], "label")
              )
            },
            USE.NAMES = FALSE
          ),
          collapse = "\n"
        )
      )
    }
  }

  metadata_list
}

# Format metadata list into a string suitable for LLM prompts
#
# @param metadata_list A list of metadata generated by generate_data_metadata()
#
# @return A formatted string describing available data objects and their structure
format_metadata_for_prompt <- function(metadata_list) {
  if (length(metadata_list) == 0) {
    return("No data objects available.")
  }

  formatted_parts <- list()

  for (obj_name in names(metadata_list)) {
    meta <- metadata_list[[obj_name]]

    if (meta$type == "data.frame") {
      part <- paste(
        sprintf("## Data Object: '%s'", obj_name),
        sprintf("- Type: Data Frame"),
        sprintf("- Dimensions: %d rows Ã— %d columns", meta$nrows, meta$ncols),
        sprintf("- Columns: %s", paste(meta$columns, collapse = "\n")),
        sep = "\n"
      )
      formatted_parts[[obj_name]] <- part
    }
  }

  if (length(formatted_parts) > 0) {
    paste(formatted_parts, collapse = "\n")
  } else {
    "No data objects available."
  }
}

#' Extract R code from LLM response
#'
#' Searches for code blocks marked with ```r or ```R and extracts the code
#'
#' @param response The text response from the LLM
#'
#' @return The extracted R code as a string
#'
#' @export
extract_code_from_response <- function(response) {
  parts <- strsplit(response, "```")[[1]]

  for (i in seq_along(parts)) {
    part <- parts[i]

    if (grepl("^\\s*[rR]\\s*\\n", part)) {
      code <- sub("^\\s*[rR]\\s*\\n", "", part)
      code <- trimws(code)

      if (nchar(code) > 0) {
        return(code)
      }
    }
  }

  return("")
}

#' Extract text (non-code) from LLM response
#'
#' Extracts all text from an LLM response except for R code blocks marked
#' with ```r or ```R. This is useful for getting explanations and commentary
#' while excluding the actual code.
#'
#' @param response The text response from the LLM
#'
#' @return A character string containing all non-code text from the response
#'
#' @export
extract_text_from_response <- function(response) {
  parts <- strsplit(response, "```")[[1]]

  text_parts <- character()

  for (i in seq_along(parts)) {
    part <- parts[i]

    # If this part starts with r or R followed by newline, it's a code block - skip it
    if (grepl("^\\s*[rR]\\s*\\n", part)) {
      next
    }

    # Otherwise, it's text - add it to our collection
    text_parts <- c(text_parts, part)
  }

  # Combine all text parts and trim whitespace
  result <- paste(text_parts, collapse = "")
  result <- trimws(result)

  return(result)
}

get_data_context <- function(envir = .GlobalEnv) {
  format_metadata_for_prompt(generate_data_metadata(envir))
}

#' Generate Main LLM Prompt for Code Generation
#'
#' Creates a structured prompt for an LLM to generate R code for clinical
#' programming tasks. Combines purpose, data context, package constraints,
#' style rules, formatting rules, and task description into a single formatted string.
#'
#' @param purpose Character string describing the task and role of the LLM
#' @param data_context Character string describing available data objects
#' @param packages Character string listing approved packages for use
#' @param style_rules Character string with code generation rules
#' @param formatting_rules Character string with formatting and response format guidelines
#' @param task Character string describing the specific task to be completed
#'
#' @return A character string containing the complete formatted prompt
#'
#' @export
prod_generate_prompt <- function(purpose, data_context, packages, style_rules, formatting_rules, task) {
  paste(
    purpose,
    "\n## AVAILABLE DATA OBJECTS:",
    data_context,
    "\n## APPROVED PACKAGES FOR OUTPUT RENDERING:",
    packages,
    style_rules,
    formatting_rules,
    task,
    sep = "\n"
  )
}

#' Generate Quality Control LLM Prompt
#'
#' Creates a structured prompt for an LLM to evaluate the quality of R code.
#' Combines purpose, data context, package information, quality criteria,
#' and task description into a single formatted string for code review tasks.
#'
#' @param purpose Character string describing the evaluation task and role
#' @param data_context Character string describing available data objects
#' @param packages Character string listing approved packages
#' @param quality_criteria Character string with quality evaluation standards
#' @param style_rules Character string with code generation rules
#' @param task Character string describing the specific evaluation task
#' @param code Code that is supposed to be quality checked and rewritten
#'
#' @return A character string containing the complete formatted QC prompt
#'
#' @export
qc_generate_prompt <- function(purpose, data_context, packages, quality_criteria, style_rules, formatting_rules, task, code) {
   paste(
    purpose,
    "\n## AVAILABLE DATA OBJECTS:",
    data_context,
    "\n## APPROVED PACKAGES FOR OUTPUT RENDERING:",
    packages,
    quality_criteria,
    style_rules,
    task,
    "\n## CODE TO EVALUATE\n```r",
    code,
    "\n```r",
    formatting_rules,
    sep = "\n"
  )
}

test_code <- function() {

  # Let's try to run the code!
  qc_result <- tryCatch(
    {
      eval(parse(text = qc_code))
    },
    error = function(e) {
      return(list(success = FALSE, error = e$message))
    }
  )

  # If there was an error, send it back to the QC agent for a fix
  if (!is.null(qc_result$error)) {
    error_message <- paste(
      "That code had an error. Please fix it and provide corrected code.",
      "\nError message:",
      qc_result$error
    )

    qc_response <- qc_agent_chat$chat(error_message, echo = FALSE)

    # Extract the corrected code
    qc_code <- extract_code_from_response(qc_response)
    qc_text <- extract_text_from_response(qc_response)

    cat("\n\n=== QC Agent's Fix ===\n")
    cat(qc_text)

    # Try running the corrected code
    qc_result <- tryCatch(
      {
        eval(parse(text = qc_code))
      },
      error = function(e) {
        return(list(success = FALSE, error = e$message))
      }
    )
  }
}